/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.mydsl1.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lightweightDSL.App
import java.net.Authenticator
import org.eclipse.emf.common.util.EList
import lightweightDSL.FactorValue
import lightweightDSL.LEVEL
import java.util.logging.Level
import lightweightDSL.Factor
import lightweightDSL.Registration
import lightweightDSL.impl.RegistrationImpl
import lightweightDSL.Provider
import lightweightDSL.Login
import lightweightDSL.SFA
import javax.print.attribute.Attribute
import lightweightDSL.Utils
import lightweightDSL.Knowledge
import lightweightDSL.KVALUE
import lightweightDSL.Risk
import lightweightDSL.impl.RiskImpl
import lightweightDSL.LightweightDSLFactory
import lightweightDSL.impl.KnowledgeImpl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LightweightGenerator extends AbstractGenerator {
	/*
	 * Authentication Factor
	 */
	public static final String POSSESSION = "Possession";
	public static final String BIOMETRICS = "Biometrics";
	public static final String KNOWLEDGE = "Knowledge";
	
	/*
	 * Method af authentication
	 */
	
	public static final String SFA = "SFA";
	public static final String MFA = "MFA";

	/*
	 * Procedures
	 */
	
	public final static String REGISTRATION = "Registration";
	public static final String LOGIN = "Login"; 
	public static final String RESET = "Reset"; 
	public static final String RECOVERY = "Recovery";
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		
	val app = resource.contents.head as App
		
		// Initiate authenticator
		app.initAuthenticator 
		
		// Initiate authentication methods
		app.initAuthentications
		
		// Assign methods security level
		app.assignMethod
	}
	
	// function to initialize authenticators
	def initAuthenticator(App app) {
		for(auth : app.authenticators) {
			auth.risk = LightweightDSLFactory.eINSTANCE.createRisk // Instantiate risk.
			switch(auth.type) {
				case POSSESSION : {
					auth.risk.instance = POSSESSION
					auth.risk.value = LEVEL.MEDIUM
					auth.risk.message = "Use of possession based authenticator"
					auth.risk.information = ""
				}
				
				case BIOMETRICS : {
					auth.risk.instance = BIOMETRICS
					auth.risk.value = LEVEL.LOW
					auth.risk.message = "Use of biometrics based authenticator"
					auth.risk.information = ""
				}
				
				case KNOWLEDGE : {
					val knowledgeAuth = auth as Knowledge
					auth.risk.instance = KNOWLEDGE
					
					//Basic evaluation 
					if (knowledgeAuth.value == KVALUE.PREFERENCES) {
						
						auth.risk.value = LEVEL.HIGH
						auth.risk.message = "Use of preference based authenticator "+auth.name+"!" 
						auth.risk.information = ""	
						
					} else if(knowledgeAuth.value == KVALUE.PIN || knowledgeAuth.value == KVALUE.LTBP){
						
						auth.risk.value = LEVEL.MEDIUM // 
						auth.risk.message = "Use of low security text based "+auth.name+"!" 
						auth.risk.information = ""	
						
					} else {
						auth.risk.value = LEVEL.LOW 
						auth.risk.message = "Use of strong text based authentication "+auth.name+"!" 
						auth.risk.information = ""
						
					}
					
					//Refactoring with the autofilled form and the number of attempts.
					
					if (!knowledgeAuth.limitedAttempts || knowledgeAuth.autofilled) {
						if(knowledgeAuth.autofilled) {
							if(auth.risk.value < LEVEL.MEDIUM) { // Low security level.
								auth.risk.value = LEVEL.MEDIUM // 
								auth.risk.message.concat("\n The risk is raised because of the use of autofillable form considered as possession-based authentication")
								auth.risk.information = ""	
							} // Level is high because of preferences.
						} else {
							
							if(auth.risk.value ==  LEVEL.MEDIUM) { // From medium to high
								auth.risk.value = LEVEL.HIGH // 
								auth.risk.message.concat("\n The risk is raised because of the unlimited attempts")
								auth.risk.information = ""	
							}
							
							if (auth.risk.value ==  LEVEL.LOW) { // from low to medium
								auth.risk.value = LEVEL.MEDIUM // 
								auth.risk.message.concat("\n The risk is raised from LOW to MEDIUM because of the unlimited attempts")
								auth.risk.information = ""	
							}
						}
					}
				}
			}
		}
		
	}
	
	def initAuthentications(App app) {
		for(method : app.authMethods) {
		//	method.risk = LightweightDSLFactory.eINSTANCE.createRisk
			if(method.type == SFA) {
				method.risk = method.authenticators.get(0).risk;
			} else {
				// TODO correlation and type of validation.
				method.risk = maximum(method.authenticators.get(0).risk,method.authenticators.get(1).risk)
			}
		}
	}
	
	def maximum (Risk r1, Risk r2) { //  the max is the lowest. 
		if(r1.value <= r2.value) // Low = 0, Medium = 1, High = 2 .
			return r1
		return r2	
	}
	
	
	def assignMethod(App app) {
		println("Initializing methods for each phases")
		for(phase : app.phases) {
			phase.risk = LightweightDSLFactory.eINSTANCE.createRisk
			switch(phase.type) {
				case REGISTRATION : {
					val r = phase as Registration
					phase.risk.instance = REGISTRATION
					
					for(attribute : r.attributes) {
						attribute.risk = LightweightDSLFactory.eINSTANCE.createRisk
						if(!attribute.verifmethod.uniqueness && 
							!attribute.verifmethod.validity && 
							!attribute.verifmethod.bindings ) {
							attribute.risk.value = LEVEL.HIGH
							attribute.risk.message = attribute.name+ " : No requirements are satisfied "
							attribute.risk.information = ""
						}
						else if (!attribute.verifmethod.uniqueness || 
							!attribute.verifmethod.validity || 
							!attribute.verifmethod.bindings) {
							attribute.risk.value = LEVEL.MEDIUM
							attribute.risk.message = attribute.name+ ": One or two requirements are unsatisfied"
							attribute.risk.information = ""
	
						} 
						else {
							attribute.risk.value = LEVEL.LOW
							attribute.risk.message = attribute.name+" : All requirements are satisfied"
							attribute.risk.information = ""
	
						}
						// Additional risk for informational report
						if(attribute.provider == Provider.ID_P) {
							if(attribute.risk.value < LEVEL.MEDIUM) {
							attribute.risk.value = LEVEL.MEDIUM
							attribute.risk.message = attribute.name+ " :Identity provider put the risk to MEDIUM"
							attribute.risk.information = ""
							} else {
								attribute.risk.information = ""
							}
						}
						
					}
					
					app.registration = r as Registration // initializing the main registration
					
					//TODO show level per attributes.
					for (attr : app.registration.attributes) {
						println("Attribute "+attr.name+" has risk level " +attr.risk.value)
					}
				}
				
				case Utils.LOGIN : {
					val login = phase as Login 
					
				}
				
				case Utils.RESET : {
					//TODO 
				}
				
				case Utils.RECOVERY : {
					//TODO
				}
				
				
			}
		}
	}
	
	
}
