/*
 * generated by Xtext 2.15.0
 */
package org.xtext.example.mydsl1.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import lightweightDSL.App
import java.net.Authenticator
import org.eclipse.emf.common.util.EList
import lightweightDSL.FactorValue
import lightweightDSL.LEVEL
import java.util.logging.Level
import lightweightDSL.Factor
import lightweightDSL.Registration
import lightweightDSL.impl.RegistrationImpl
import lightweightDSL.Provider
import lightweightDSL.Login
import lightweightDSL.SFA
import javax.print.attribute.Attribute
import lightweightDSL.Utils
import lightweightDSL.Knowledge
import lightweightDSL.KVALUE
import lightweightDSL.Risk
import lightweightDSL.impl.RiskImpl
import lightweightDSL.LightweightDSLFactory
import lightweightDSL.impl.KnowledgeImpl
import java.util.Comparator
import lightweightDSL.AuthMethod
import lightweightDSL.Reset
import lightweightDSL.Recovery
import java.util.List
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LightweightGenerator extends AbstractGenerator {
	/*
	 * Authentication Factor
	 */
	public static final String POSSESSION = "Possession";
	public static final String BIOMETRICS = "Biometrics";
	public static final String KNOWLEDGE = "Knowledge";
	
	/*
	 * Method af authentication
	 */
	
	public static final String SFA = "SFA";
	public static final String MFA = "MFA";

	/*
	 * Procedures
	 */
	
	public final static String REGISTRATION = "Registration";
	public static final String LOGIN = "Login"; 
	public static final String RESET = "Reset"; 
	public static final String RECOVERY = "Recovery";
		
	Registration mainRegistration
	Login mainLogin
	List<Reset> resets = new ArrayList // List of existing reset
	List<Recovery> recoveries = new ArrayList // List of existing recovery
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))

		
	val app = resource.contents.head as App
		
//		val mainLogin = LightweightDSLFactory.eINSTANCE.createLogin
//		val mainReset =  LightweightDSLFactory.eINSTANCE.createReset
//		val mainRecovery = LightweightDSLFactory.eINSTANCE.createRecovery
//		val mainRegistration = LightweightDSLFactory.eINSTANCE.createRegistration 
		
		
		// Initiate authenticator
		app.initAuthenticator 
		
		// Initiate authentication methods
		app.initAuthentications
		
		// Assign methods security level
		app.assignMethod
	}
	
	// function to initialize authenticators
	def initAuthenticator(App app) {
		for(auth : app.authenticators) {
			auth.risk = LightweightDSLFactory.eINSTANCE.createRisk // Instantiate risk.
			switch(auth.type) {
				case POSSESSION : {
					auth.risk.instance = POSSESSION
					auth.risk.value = LEVEL.MEDIUM
					auth.risk.message = "Use of possession based authenticator"
					auth.risk.information = ""
				}
				
				case BIOMETRICS : {
					auth.risk.instance = BIOMETRICS
					auth.risk.value = LEVEL.LOW
					auth.risk.message = "Use of biometrics based authenticator"
					auth.risk.information = ""
				}
				
				case KNOWLEDGE : {
					val knowledgeAuth = auth as Knowledge
					auth.risk.instance = KNOWLEDGE
					
					//Basic evaluation 
					if (knowledgeAuth.value == KVALUE.PREFERENCES) {
						
						auth.risk.value = LEVEL.HIGH
						auth.risk.message = "Use of preference based authenticator "+auth.name+"!" 
						auth.risk.information = ""	
						
					} else if(knowledgeAuth.value == KVALUE.PIN || knowledgeAuth.value == KVALUE.LTBP){
						
						auth.risk.value = LEVEL.MEDIUM // 
						auth.risk.message = "Use of low security text based "+auth.name+"!" 
						auth.risk.information = ""	
						
					} else {
						auth.risk.value = LEVEL.LOW 
						auth.risk.message = "Use of strong text based authentication "+auth.name+"!" 
						auth.risk.information = ""
						
					}
					
					//Refactoring with the autofilled form and the number of attempts.
					
					if (!knowledgeAuth.limitedAttempts || knowledgeAuth.autofilled) {
						if(knowledgeAuth.autofilled) {
							if(auth.risk.value < LEVEL.MEDIUM) { // Low security level.
								auth.risk.value = LEVEL.MEDIUM // 
								auth.risk.message.concat("\n The risk is raised because of the use of autofillable form considered as possession-based authentication")
								auth.risk.information = ""	
							} // Level is high because of preferences.
						} else {
							
							if(auth.risk.value ==  LEVEL.MEDIUM) { // From medium to high
								auth.risk.value = LEVEL.HIGH // 
								auth.risk.message.concat("\n The risk is raised because of the unlimited attempts")
								auth.risk.information = ""	
							}
							
							if (auth.risk.value ==  LEVEL.LOW) { // from low to medium
								auth.risk.value = LEVEL.MEDIUM // 
								auth.risk.message.concat("\n The risk is raised from LOW to MEDIUM because of the unlimited attempts")
								auth.risk.information = ""	
							}
						}
					}
				}
			}
		}
		
	}
	
	def initAuthentications(App app) {
		for(method : app.authMethods) {
		//	method.risk = LightweightDSLFactory.eINSTANCE.createRisk
			if(method.type == SFA) {
				method.risk = method.authenticators.get(0).risk;
			} else {
				// TODO correlation and type of validation.
				method.risk.value = maximum(method.authenticators.get(0).risk.value,method.authenticators.get(1).risk.value)
			}
		}
	}

	
	def assignMethod(App app) {
		println("Initializing methods for each phases")
		for(phase : app.phases) {
			phase.risk = LightweightDSLFactory.eINSTANCE.createRisk
			switch(phase.type) {
				case REGISTRATION : {
					val r = phase as Registration
					r.risk.instance = REGISTRATION
					
					for(attribute : r.attributes) {
						attribute.risk = LightweightDSLFactory.eINSTANCE.createRisk
						if(!attribute.verifmethod.uniqueness && 
							!attribute.verifmethod.validity && 
							!attribute.verifmethod.bindings ) {
							attribute.risk.value = LEVEL.HIGH
							attribute.risk.message = attribute.name+ " : No requirements are satisfied "
							attribute.risk.information = ""
						}
						else if (!attribute.verifmethod.uniqueness || 
							!attribute.verifmethod.validity || 
							!attribute.verifmethod.bindings) {
							attribute.risk.value = LEVEL.MEDIUM
							attribute.risk.message = attribute.name+ ": One or two requirements are unsatisfied"
							attribute.risk.information = ""
	
						} 
						else {
							attribute.risk.value = LEVEL.LOW
							attribute.risk.message = attribute.name+" : All requirements are satisfied"
							attribute.risk.information = ""
	
						}
						// Additional risk for informational report
						if(attribute.provider == Provider.ID_P) {
							if(attribute.risk.value < LEVEL.MEDIUM) {
							attribute.risk.value = LEVEL.MEDIUM
							attribute.risk.message = attribute.name+ " :Identity provider put the risk to MEDIUM"
							attribute.risk.information = ""
							} else {
								attribute.risk.information = ""
							}
						}
					}
					
					mainRegistration = r as Registration // assigning the main registration
					
					//TODO show level per attributes.
					println("Registration Risk Assessment")
					for (attr : mainRegistration.attributes) {
						println("Attribute ("+attr.name+") has risk level (" +attr.risk.value+")")
					}
				}
				
				case LOGIN : {
					val login = phase as Login 
					login.risk.instance = LOGIN
					if(login.authMethods.size != 1) {
						var comp = new MethodComparator()
						login.authMethods.sortInplace(comp) // reverse short (see comparator)
						login.risk.value = login.authMethods.last.risk.value 	
						login.risk.message = "Multiple method but, the referenced authentication method is ("+ login.authMethods.last+")"
						login.risk.information = ""
						mainLogin = login as Login
						} else {
						println("main authentication method" + login.authMethods.get(0))
						login.risk.message = "One referenced authentication method is ( \n "+ login.authMethods.get(0)+")"
						login.risk.value = login.authMethods.get(0).risk.value
						login.risk.information = ""
						mainLogin = login as Login
					}
					
					// Is persisted session
					if(login.session) {
						mainLogin.risk.message.concat("\n ----- Persisted Session detected ------\n The risk level is at most Medium ")
						mainLogin.risk.value = maximum(mainLogin.risk.value, LEVEL.MEDIUM)
						mainLogin.risk.information.concat("")
					}
					// Main login risk level.
				println("Login Risk Assessment")
				println ("Login risk level : \n name : " +mainLogin.name+ "
							\n Evaluation : " +mainLogin.risk.toString)					
				}
				
				/**
				 * This allow to verify : 
				 * Weak path because the @Risk level of the @Authenticor to recover shall be 
				 * lower than the authentication method
				 */
				case RESET : {
					val reset = phase as Reset 
					reset.risk.instance = RESET
					// The case of reset with auth methods and persisted session
					if(reset.authMethods.size == 0) {
						reset.risk.information = "It is highly recommended to use a security challenge to before reseting credential and also before sensitive action such as payment"
						if(mainLogin.session) {
							reset.risk.value  = maximum(LEVEL.MEDIUM, mainLogin.risk.value)
							reset.risk.message = "Because of the persistent session the risk level is at most MEDIUM (considered as Possession based"
						} else {
							reset.risk.value  = mainLogin.risk.value
							reset.risk.message = "No Persistent Session : The risk level of the Reset (" +reset.name+ ") is given by the MainLogin (" +mainLogin.name+ ")"
						}
					}else {
						var comp = new MethodComparator()
						reset.authMethods.sortInplace(comp) // reverse short (see comparator)
						reset.risk.message = "Multiple method but, the referenced authentication method is (\n"+ reset.authMethods.last.toString+")"
						reset.risk.message.concat("\n, Reset Challenge with no persistent challenge : The risk level is at LEAST the ")
						reset.risk.value = maximum (reset.authMethods.last.risk.value, mainLogin.risk.value) 	
						reset.risk.message.concat("\n, Reset Challenge with no persistent challenge : The risk level is evaluated as two factor authentication between the Challenge ("
							+reset.authMethods.last.toString+ ") and the mainLogin authentication ("+mainLogin.authMethods.last.toString+ (")")
						)
					}
					
					// Adding to the list of reset function
					println("Reset Risk Assessment")
					println ("Reset risk level : \n name : " +reset.name+ "
							\n Evaluation : " +reset.risk.toString)
					resets.add(reset)
				}
				case RECOVERY : {
					//TODO
				}
			}
		}
	}
	
	/**
	 * Max between level
	 */
	def maximum (LEVEL l1, LEVEL l2) { //  the max is the lowest. 
		if(l1.value <= l2.value) // Low = 0, Medium = 1, High = 2 .
			return l1
		return l2	
	}
	
	/**
	 * Max between risk
	 */
	def maximum (Risk r1, Risk r2) { //  the max is the lowest. 
		if(r1.value <= r2.value) // Low = 0, Medium = 1, High = 2 .
			return r1
		return r2	
	}
	
	
	/*
	 * Authentication method comparator
	 */
	static class MethodComparator implements Comparator<AuthMethod> {  
		
	    override int compare (AuthMethod a1, AuthMethod a2)
		    {
		       return a1.risk.value.compareTo(a2.risk.value);
		    }
	}


}

